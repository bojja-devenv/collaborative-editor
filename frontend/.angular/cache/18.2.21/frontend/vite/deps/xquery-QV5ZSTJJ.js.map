{
  "version": 3,
  "sources": ["../../../../../../node_modules/@codemirror/legacy-modes/mode/xquery.js"],
  "sourcesContent": ["// The keywords object is set to the result of this self executing\n// function. Each keyword is a property of the keywords object whose\n// value is {type: atype, style: astyle}\nvar keywords = function () {\n  // convenience functions used to build keywords object\n  function kw(type) {\n    return {\n      type: type,\n      style: \"keyword\"\n    };\n  }\n  var operator = kw(\"operator\"),\n    atom = {\n      type: \"atom\",\n      style: \"atom\"\n    },\n    punctuation = {\n      type: \"punctuation\",\n      style: null\n    },\n    qualifier = {\n      type: \"axis_specifier\",\n      style: \"qualifier\"\n    };\n\n  // kwObj is what is return from this function at the end\n  var kwObj = {\n    ',': punctuation\n  };\n\n  // a list of 'basic' keywords. For each add a property to kwObj with the value of\n  // {type: basic[i], style: \"keyword\"} e.g. 'after' --> {type: \"after\", style: \"keyword\"}\n  var basic = ['after', 'all', 'allowing', 'ancestor', 'ancestor-or-self', 'any', 'array', 'as', 'ascending', 'at', 'attribute', 'base-uri', 'before', 'boundary-space', 'by', 'case', 'cast', 'castable', 'catch', 'child', 'collation', 'comment', 'construction', 'contains', 'content', 'context', 'copy', 'copy-namespaces', 'count', 'decimal-format', 'declare', 'default', 'delete', 'descendant', 'descendant-or-self', 'descending', 'diacritics', 'different', 'distance', 'document', 'document-node', 'element', 'else', 'empty', 'empty-sequence', 'encoding', 'end', 'entire', 'every', 'exactly', 'except', 'external', 'first', 'following', 'following-sibling', 'for', 'from', 'ftand', 'ftnot', 'ft-option', 'ftor', 'function', 'fuzzy', 'greatest', 'group', 'if', 'import', 'in', 'inherit', 'insensitive', 'insert', 'instance', 'intersect', 'into', 'invoke', 'is', 'item', 'language', 'last', 'lax', 'least', 'let', 'levels', 'lowercase', 'map', 'modify', 'module', 'most', 'namespace', 'next', 'no', 'node', 'nodes', 'no-inherit', 'no-preserve', 'not', 'occurs', 'of', 'only', 'option', 'order', 'ordered', 'ordering', 'paragraph', 'paragraphs', 'parent', 'phrase', 'preceding', 'preceding-sibling', 'preserve', 'previous', 'processing-instruction', 'relationship', 'rename', 'replace', 'return', 'revalidation', 'same', 'satisfies', 'schema', 'schema-attribute', 'schema-element', 'score', 'self', 'sensitive', 'sentence', 'sentences', 'sequence', 'skip', 'sliding', 'some', 'stable', 'start', 'stemming', 'stop', 'strict', 'strip', 'switch', 'text', 'then', 'thesaurus', 'times', 'to', 'transform', 'treat', 'try', 'tumbling', 'type', 'typeswitch', 'union', 'unordered', 'update', 'updating', 'uppercase', 'using', 'validate', 'value', 'variable', 'version', 'weight', 'when', 'where', 'wildcards', 'window', 'with', 'without', 'word', 'words', 'xquery'];\n  for (var i = 0, l = basic.length; i < l; i++) {\n    kwObj[basic[i]] = kw(basic[i]);\n  }\n  ;\n\n  // a list of types. For each add a property to kwObj with the value of\n  // {type: \"atom\", style: \"atom\"}\n  var types = ['xs:anyAtomicType', 'xs:anySimpleType', 'xs:anyType', 'xs:anyURI', 'xs:base64Binary', 'xs:boolean', 'xs:byte', 'xs:date', 'xs:dateTime', 'xs:dateTimeStamp', 'xs:dayTimeDuration', 'xs:decimal', 'xs:double', 'xs:duration', 'xs:ENTITIES', 'xs:ENTITY', 'xs:float', 'xs:gDay', 'xs:gMonth', 'xs:gMonthDay', 'xs:gYear', 'xs:gYearMonth', 'xs:hexBinary', 'xs:ID', 'xs:IDREF', 'xs:IDREFS', 'xs:int', 'xs:integer', 'xs:item', 'xs:java', 'xs:language', 'xs:long', 'xs:Name', 'xs:NCName', 'xs:negativeInteger', 'xs:NMTOKEN', 'xs:NMTOKENS', 'xs:nonNegativeInteger', 'xs:nonPositiveInteger', 'xs:normalizedString', 'xs:NOTATION', 'xs:numeric', 'xs:positiveInteger', 'xs:precisionDecimal', 'xs:QName', 'xs:short', 'xs:string', 'xs:time', 'xs:token', 'xs:unsignedByte', 'xs:unsignedInt', 'xs:unsignedLong', 'xs:unsignedShort', 'xs:untyped', 'xs:untypedAtomic', 'xs:yearMonthDuration'];\n  for (var i = 0, l = types.length; i < l; i++) {\n    kwObj[types[i]] = atom;\n  }\n  ;\n\n  // each operator will add a property to kwObj with value of {type: \"operator\", style: \"keyword\"}\n  var operators = ['eq', 'ne', 'lt', 'le', 'gt', 'ge', ':=', '=', '>', '>=', '<', '<=', '.', '|', '?', 'and', 'or', 'div', 'idiv', 'mod', '*', '/', '+', '-'];\n  for (var i = 0, l = operators.length; i < l; i++) {\n    kwObj[operators[i]] = operator;\n  }\n  ;\n\n  // each axis_specifiers will add a property to kwObj with value of {type: \"axis_specifier\", style: \"qualifier\"}\n  var axis_specifiers = [\"self::\", \"attribute::\", \"child::\", \"descendant::\", \"descendant-or-self::\", \"parent::\", \"ancestor::\", \"ancestor-or-self::\", \"following::\", \"preceding::\", \"following-sibling::\", \"preceding-sibling::\"];\n  for (var i = 0, l = axis_specifiers.length; i < l; i++) {\n    kwObj[axis_specifiers[i]] = qualifier;\n  }\n  ;\n  return kwObj;\n}();\nfunction chain(stream, state, f) {\n  state.tokenize = f;\n  return f(stream, state);\n}\n\n// the primary mode tokenizer\nfunction tokenBase(stream, state) {\n  var ch = stream.next(),\n    mightBeFunction = false,\n    isEQName = isEQNameAhead(stream);\n\n  // an XML tag (if not in some sub, chained tokenizer)\n  if (ch == \"<\") {\n    if (stream.match(\"!--\", true)) return chain(stream, state, tokenXMLComment);\n    if (stream.match(\"![CDATA\", false)) {\n      state.tokenize = tokenCDATA;\n      return \"tag\";\n    }\n    if (stream.match(\"?\", false)) {\n      return chain(stream, state, tokenPreProcessing);\n    }\n    var isclose = stream.eat(\"/\");\n    stream.eatSpace();\n    var tagName = \"\",\n      c;\n    while (c = stream.eat(/[^\\s\\u00a0=<>\\\"\\'\\/?]/)) tagName += c;\n    return chain(stream, state, tokenTag(tagName, isclose));\n  }\n  // start code block\n  else if (ch == \"{\") {\n    pushStateStack(state, {\n      type: \"codeblock\"\n    });\n    return null;\n  }\n  // end code block\n  else if (ch == \"}\") {\n    popStateStack(state);\n    return null;\n  }\n  // if we're in an XML block\n  else if (isInXmlBlock(state)) {\n    if (ch == \">\") return \"tag\";else if (ch == \"/\" && stream.eat(\">\")) {\n      popStateStack(state);\n      return \"tag\";\n    } else return \"variable\";\n  }\n  // if a number\n  else if (/\\d/.test(ch)) {\n    stream.match(/^\\d*(?:\\.\\d*)?(?:E[+\\-]?\\d+)?/);\n    return \"atom\";\n  }\n  // comment start\n  else if (ch === \"(\" && stream.eat(\":\")) {\n    pushStateStack(state, {\n      type: \"comment\"\n    });\n    return chain(stream, state, tokenComment);\n  }\n  // quoted string\n  else if (!isEQName && (ch === '\"' || ch === \"'\")) return startString(stream, state, ch);\n  // variable\n  else if (ch === \"$\") {\n    return chain(stream, state, tokenVariable);\n  }\n  // assignment\n  else if (ch === \":\" && stream.eat(\"=\")) {\n    return \"keyword\";\n  }\n  // open paren\n  else if (ch === \"(\") {\n    pushStateStack(state, {\n      type: \"paren\"\n    });\n    return null;\n  }\n  // close paren\n  else if (ch === \")\") {\n    popStateStack(state);\n    return null;\n  }\n  // open paren\n  else if (ch === \"[\") {\n    pushStateStack(state, {\n      type: \"bracket\"\n    });\n    return null;\n  }\n  // close paren\n  else if (ch === \"]\") {\n    popStateStack(state);\n    return null;\n  } else {\n    var known = keywords.propertyIsEnumerable(ch) && keywords[ch];\n\n    // if there's a EQName ahead, consume the rest of the string portion, it's likely a function\n    if (isEQName && ch === '\\\"') while (stream.next() !== '\"') {}\n    if (isEQName && ch === '\\'') while (stream.next() !== '\\'') {}\n\n    // gobble up a word if the character is not known\n    if (!known) stream.eatWhile(/[\\w\\$_-]/);\n\n    // gobble a colon in the case that is a lib func type call fn:doc\n    var foundColon = stream.eat(\":\");\n\n    // if there's not a second colon, gobble another word. Otherwise, it's probably an axis specifier\n    // which should get matched as a keyword\n    if (!stream.eat(\":\") && foundColon) {\n      stream.eatWhile(/[\\w\\$_-]/);\n    }\n    // if the next non whitespace character is an open paren, this is probably a function (if not a keyword of other sort)\n    if (stream.match(/^[ \\t]*\\(/, false)) {\n      mightBeFunction = true;\n    }\n    // is the word a keyword?\n    var word = stream.current();\n    known = keywords.propertyIsEnumerable(word) && keywords[word];\n\n    // if we think it's a function call but not yet known,\n    // set style to variable for now for lack of something better\n    if (mightBeFunction && !known) known = {\n      type: \"function_call\",\n      style: \"def\"\n    };\n\n    // if the previous word was element, attribute, axis specifier, this word should be the name of that\n    if (isInXmlConstructor(state)) {\n      popStateStack(state);\n      return \"variable\";\n    }\n    // as previously checked, if the word is element,attribute, axis specifier, call it an \"xmlconstructor\" and\n    // push the stack so we know to look for it on the next word\n    if (word == \"element\" || word == \"attribute\" || known.type == \"axis_specifier\") pushStateStack(state, {\n      type: \"xmlconstructor\"\n    });\n\n    // if the word is known, return the details of that else just call this a generic 'word'\n    return known ? known.style : \"variable\";\n  }\n}\n\n// handle comments, including nested\nfunction tokenComment(stream, state) {\n  var maybeEnd = false,\n    maybeNested = false,\n    nestedCount = 0,\n    ch;\n  while (ch = stream.next()) {\n    if (ch == \")\" && maybeEnd) {\n      if (nestedCount > 0) nestedCount--;else {\n        popStateStack(state);\n        break;\n      }\n    } else if (ch == \":\" && maybeNested) {\n      nestedCount++;\n    }\n    maybeEnd = ch == \":\";\n    maybeNested = ch == \"(\";\n  }\n  return \"comment\";\n}\n\n// tokenizer for string literals\n// optionally pass a tokenizer function to set state.tokenize back to when finished\nfunction tokenString(quote, f) {\n  return function (stream, state) {\n    var ch;\n    while (ch = stream.next()) {\n      if (ch == quote) {\n        popStateStack(state);\n        if (f) state.tokenize = f;\n        break;\n      } else if (stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\n        // if we're in a string and in an XML block, allow an embedded code block in an attribute\n        pushStateStack(state, {\n          type: \"codeblock\"\n        });\n        state.tokenize = tokenBase;\n        return \"string\";\n      }\n    }\n    return \"string\";\n  };\n}\nfunction startString(stream, state, quote, f) {\n  let tokenize = tokenString(quote, f);\n  pushStateStack(state, {\n    type: \"string\",\n    name: quote,\n    tokenize\n  });\n  return chain(stream, state, tokenize);\n}\n\n// tokenizer for variables\nfunction tokenVariable(stream, state) {\n  var isVariableChar = /[\\w\\$_-]/;\n\n  // a variable may start with a quoted EQName so if the next character is quote, consume to the next quote\n  if (stream.eat(\"\\\"\")) {\n    while (stream.next() !== '\\\"') {}\n    ;\n    stream.eat(\":\");\n  } else {\n    stream.eatWhile(isVariableChar);\n    if (!stream.match(\":=\", false)) stream.eat(\":\");\n  }\n  stream.eatWhile(isVariableChar);\n  state.tokenize = tokenBase;\n  return \"variable\";\n}\n\n// tokenizer for XML tags\nfunction tokenTag(name, isclose) {\n  return function (stream, state) {\n    stream.eatSpace();\n    if (isclose && stream.eat(\">\")) {\n      popStateStack(state);\n      state.tokenize = tokenBase;\n      return \"tag\";\n    }\n    // self closing tag without attributes?\n    if (!stream.eat(\"/\")) pushStateStack(state, {\n      type: \"tag\",\n      name: name,\n      tokenize: tokenBase\n    });\n    if (!stream.eat(\">\")) {\n      state.tokenize = tokenAttribute;\n      return \"tag\";\n    } else {\n      state.tokenize = tokenBase;\n    }\n    return \"tag\";\n  };\n}\n\n// tokenizer for XML attributes\nfunction tokenAttribute(stream, state) {\n  var ch = stream.next();\n  if (ch == \"/\" && stream.eat(\">\")) {\n    if (isInXmlAttributeBlock(state)) popStateStack(state);\n    if (isInXmlBlock(state)) popStateStack(state);\n    return \"tag\";\n  }\n  if (ch == \">\") {\n    if (isInXmlAttributeBlock(state)) popStateStack(state);\n    return \"tag\";\n  }\n  if (ch == \"=\") return null;\n  // quoted string\n  if (ch == '\"' || ch == \"'\") return startString(stream, state, ch, tokenAttribute);\n  if (!isInXmlAttributeBlock(state)) pushStateStack(state, {\n    type: \"attribute\",\n    tokenize: tokenAttribute\n  });\n  stream.eat(/[a-zA-Z_:]/);\n  stream.eatWhile(/[-a-zA-Z0-9_:.]/);\n  stream.eatSpace();\n\n  // the case where the attribute has not value and the tag was closed\n  if (stream.match(\">\", false) || stream.match(\"/\", false)) {\n    popStateStack(state);\n    state.tokenize = tokenBase;\n  }\n  return \"attribute\";\n}\n\n// handle comments, including nested\nfunction tokenXMLComment(stream, state) {\n  var ch;\n  while (ch = stream.next()) {\n    if (ch == \"-\" && stream.match(\"->\", true)) {\n      state.tokenize = tokenBase;\n      return \"comment\";\n    }\n  }\n}\n\n// handle CDATA\nfunction tokenCDATA(stream, state) {\n  var ch;\n  while (ch = stream.next()) {\n    if (ch == \"]\" && stream.match(\"]\", true)) {\n      state.tokenize = tokenBase;\n      return \"comment\";\n    }\n  }\n}\n\n// handle preprocessing instructions\nfunction tokenPreProcessing(stream, state) {\n  var ch;\n  while (ch = stream.next()) {\n    if (ch == \"?\" && stream.match(\">\", true)) {\n      state.tokenize = tokenBase;\n      return \"processingInstruction\";\n    }\n  }\n}\n\n// functions to test the current context of the state\nfunction isInXmlBlock(state) {\n  return isIn(state, \"tag\");\n}\nfunction isInXmlAttributeBlock(state) {\n  return isIn(state, \"attribute\");\n}\nfunction isInXmlConstructor(state) {\n  return isIn(state, \"xmlconstructor\");\n}\nfunction isInString(state) {\n  return isIn(state, \"string\");\n}\nfunction isEQNameAhead(stream) {\n  // assume we've already eaten a quote (\")\n  if (stream.current() === '\"') return stream.match(/^[^\\\"]+\\\"\\:/, false);else if (stream.current() === '\\'') return stream.match(/^[^\\\"]+\\'\\:/, false);else return false;\n}\nfunction isIn(state, type) {\n  return state.stack.length && state.stack[state.stack.length - 1].type == type;\n}\nfunction pushStateStack(state, newState) {\n  state.stack.push(newState);\n}\nfunction popStateStack(state) {\n  state.stack.pop();\n  var reinstateTokenize = state.stack.length && state.stack[state.stack.length - 1].tokenize;\n  state.tokenize = reinstateTokenize || tokenBase;\n}\n\n// the interface for the mode API\nexport const xQuery = {\n  name: \"xquery\",\n  startState: function () {\n    return {\n      tokenize: tokenBase,\n      cc: [],\n      stack: []\n    };\n  },\n  token: function (stream, state) {\n    if (stream.eatSpace()) return null;\n    var style = state.tokenize(stream, state);\n    return style;\n  },\n  languageData: {\n    commentTokens: {\n      block: {\n        open: \"(:\",\n        close: \":)\"\n      }\n    }\n  }\n};"],
  "mappings": "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",
  "names": []
}
