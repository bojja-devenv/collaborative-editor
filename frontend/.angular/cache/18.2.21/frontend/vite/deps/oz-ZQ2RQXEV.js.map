{
  "version": 3,
  "sources": ["../../../../../../node_modules/@codemirror/legacy-modes/mode/oz.js"],
  "sourcesContent": ["function wordRegexp(words) {\n  return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n}\nvar singleOperators = /[\\^@!\\|<>#~\\.\\*\\-\\+\\\\/,=]/;\nvar doubleOperators = /(<-)|(:=)|(=<)|(>=)|(<=)|(<:)|(>:)|(=:)|(\\\\=)|(\\\\=:)|(!!)|(==)|(::)/;\nvar tripleOperators = /(:::)|(\\.\\.\\.)|(=<:)|(>=:)/;\nvar middle = [\"in\", \"then\", \"else\", \"of\", \"elseof\", \"elsecase\", \"elseif\", \"catch\", \"finally\", \"with\", \"require\", \"prepare\", \"import\", \"export\", \"define\", \"do\"];\nvar end = [\"end\"];\nvar atoms = wordRegexp([\"true\", \"false\", \"nil\", \"unit\"]);\nvar commonKeywords = wordRegexp([\"andthen\", \"at\", \"attr\", \"declare\", \"feat\", \"from\", \"lex\", \"mod\", \"div\", \"mode\", \"orelse\", \"parser\", \"prod\", \"prop\", \"scanner\", \"self\", \"syn\", \"token\"]);\nvar openingKeywords = wordRegexp([\"local\", \"proc\", \"fun\", \"case\", \"class\", \"if\", \"cond\", \"or\", \"dis\", \"choice\", \"not\", \"thread\", \"try\", \"raise\", \"lock\", \"for\", \"suchthat\", \"meth\", \"functor\"]);\nvar middleKeywords = wordRegexp(middle);\nvar endKeywords = wordRegexp(end);\n\n// Tokenizers\nfunction tokenBase(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  // Brackets\n  if (stream.match(/[{}]/)) {\n    return \"bracket\";\n  }\n\n  // Special [] keyword\n  if (stream.match('[]')) {\n    return \"keyword\";\n  }\n\n  // Operators\n  if (stream.match(tripleOperators) || stream.match(doubleOperators)) {\n    return \"operator\";\n  }\n\n  // Atoms\n  if (stream.match(atoms)) {\n    return 'atom';\n  }\n\n  // Opening keywords\n  var matched = stream.match(openingKeywords);\n  if (matched) {\n    if (!state.doInCurrentLine) state.currentIndent++;else state.doInCurrentLine = false;\n\n    // Special matching for signatures\n    if (matched[0] == \"proc\" || matched[0] == \"fun\") state.tokenize = tokenFunProc;else if (matched[0] == \"class\") state.tokenize = tokenClass;else if (matched[0] == \"meth\") state.tokenize = tokenMeth;\n    return 'keyword';\n  }\n\n  // Middle and other keywords\n  if (stream.match(middleKeywords) || stream.match(commonKeywords)) {\n    return \"keyword\";\n  }\n\n  // End keywords\n  if (stream.match(endKeywords)) {\n    state.currentIndent--;\n    return 'keyword';\n  }\n\n  // Eat the next char for next comparisons\n  var ch = stream.next();\n\n  // Strings\n  if (ch == '\"' || ch == \"'\") {\n    state.tokenize = tokenString(ch);\n    return state.tokenize(stream, state);\n  }\n\n  // Numbers\n  if (/[~\\d]/.test(ch)) {\n    if (ch == \"~\") {\n      if (!/^[0-9]/.test(stream.peek())) return null;else if (stream.next() == \"0\" && stream.match(/^[xX][0-9a-fA-F]+/) || stream.match(/^[0-9]*(\\.[0-9]+)?([eE][~+]?[0-9]+)?/)) return \"number\";\n    }\n    if (ch == \"0\" && stream.match(/^[xX][0-9a-fA-F]+/) || stream.match(/^[0-9]*(\\.[0-9]+)?([eE][~+]?[0-9]+)?/)) return \"number\";\n    return null;\n  }\n\n  // Comments\n  if (ch == \"%\") {\n    stream.skipToEnd();\n    return 'comment';\n  } else if (ch == \"/\") {\n    if (stream.eat(\"*\")) {\n      state.tokenize = tokenComment;\n      return tokenComment(stream, state);\n    }\n  }\n\n  // Single operators\n  if (singleOperators.test(ch)) {\n    return \"operator\";\n  }\n\n  // If nothing match, we skip the entire alphanumerical block\n  stream.eatWhile(/\\w/);\n  return \"variable\";\n}\nfunction tokenClass(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n  stream.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)/);\n  state.tokenize = tokenBase;\n  return \"type\";\n}\nfunction tokenMeth(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n  stream.match(/([a-zA-Z][A-Za-z0-9_]*)|(`.+`)/);\n  state.tokenize = tokenBase;\n  return \"def\";\n}\nfunction tokenFunProc(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n  if (!state.hasPassedFirstStage && stream.eat(\"{\")) {\n    state.hasPassedFirstStage = true;\n    return \"bracket\";\n  } else if (state.hasPassedFirstStage) {\n    stream.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)|\\$/);\n    state.hasPassedFirstStage = false;\n    state.tokenize = tokenBase;\n    return \"def\";\n  } else {\n    state.tokenize = tokenBase;\n    return null;\n  }\n}\nfunction tokenComment(stream, state) {\n  var maybeEnd = false,\n    ch;\n  while (ch = stream.next()) {\n    if (ch == \"/\" && maybeEnd) {\n      state.tokenize = tokenBase;\n      break;\n    }\n    maybeEnd = ch == \"*\";\n  }\n  return \"comment\";\n}\nfunction tokenString(quote) {\n  return function (stream, state) {\n    var escaped = false,\n      next,\n      end = false;\n    while ((next = stream.next()) != null) {\n      if (next == quote && !escaped) {\n        end = true;\n        break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    if (end || !escaped) state.tokenize = tokenBase;\n    return \"string\";\n  };\n}\nfunction buildElectricInputRegEx() {\n  // Reindentation should occur on [] or on a match of any of\n  // the block closing keywords, at the end of a line.\n  var allClosings = middle.concat(end);\n  return new RegExp(\"[\\\\[\\\\]]|(\" + allClosings.join(\"|\") + \")$\");\n}\nexport const oz = {\n  name: \"oz\",\n  startState: function () {\n    return {\n      tokenize: tokenBase,\n      currentIndent: 0,\n      doInCurrentLine: false,\n      hasPassedFirstStage: false\n    };\n  },\n  token: function (stream, state) {\n    if (stream.sol()) state.doInCurrentLine = 0;\n    return state.tokenize(stream, state);\n  },\n  indent: function (state, textAfter, cx) {\n    var trueText = textAfter.replace(/^\\s+|\\s+$/g, '');\n    if (trueText.match(endKeywords) || trueText.match(middleKeywords) || trueText.match(/(\\[])/)) return cx.unit * (state.currentIndent - 1);\n    if (state.currentIndent < 0) return 0;\n    return state.currentIndent * cx.unit;\n  },\n  languageData: {\n    indentOnInut: buildElectricInputRegEx(),\n    commentTokens: {\n      line: \"%\",\n      block: {\n        open: \"/*\",\n        close: \"*/\"\n      }\n    }\n  }\n};"],
  "mappings": "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",
  "names": ["end"]
}
