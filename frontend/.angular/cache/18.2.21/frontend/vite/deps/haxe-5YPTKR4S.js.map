{
  "version": 3,
  "sources": ["../../../../../../node_modules/@codemirror/legacy-modes/mode/haxe.js"],
  "sourcesContent": ["// Tokenizer\n\nfunction kw(type) {\n  return {\n    type: type,\n    style: \"keyword\"\n  };\n}\nvar A = kw(\"keyword a\"),\n  B = kw(\"keyword b\"),\n  C = kw(\"keyword c\");\nvar operator = kw(\"operator\"),\n  atom = {\n    type: \"atom\",\n    style: \"atom\"\n  },\n  attribute = {\n    type: \"attribute\",\n    style: \"attribute\"\n  };\nvar type = kw(\"typedef\");\nvar keywords = {\n  \"if\": A,\n  \"while\": A,\n  \"else\": B,\n  \"do\": B,\n  \"try\": B,\n  \"return\": C,\n  \"break\": C,\n  \"continue\": C,\n  \"new\": C,\n  \"throw\": C,\n  \"var\": kw(\"var\"),\n  \"inline\": attribute,\n  \"static\": attribute,\n  \"using\": kw(\"import\"),\n  \"public\": attribute,\n  \"private\": attribute,\n  \"cast\": kw(\"cast\"),\n  \"import\": kw(\"import\"),\n  \"macro\": kw(\"macro\"),\n  \"function\": kw(\"function\"),\n  \"catch\": kw(\"catch\"),\n  \"untyped\": kw(\"untyped\"),\n  \"callback\": kw(\"cb\"),\n  \"for\": kw(\"for\"),\n  \"switch\": kw(\"switch\"),\n  \"case\": kw(\"case\"),\n  \"default\": kw(\"default\"),\n  \"in\": operator,\n  \"never\": kw(\"property_access\"),\n  \"trace\": kw(\"trace\"),\n  \"class\": type,\n  \"abstract\": type,\n  \"enum\": type,\n  \"interface\": type,\n  \"typedef\": type,\n  \"extends\": type,\n  \"implements\": type,\n  \"dynamic\": type,\n  \"true\": atom,\n  \"false\": atom,\n  \"null\": atom\n};\nvar isOperatorChar = /[+\\-*&%=<>!?|]/;\nfunction chain(stream, state, f) {\n  state.tokenize = f;\n  return f(stream, state);\n}\nfunction toUnescaped(stream, end) {\n  var escaped = false,\n    next;\n  while ((next = stream.next()) != null) {\n    if (next == end && !escaped) return true;\n    escaped = !escaped && next == \"\\\\\";\n  }\n}\n\n// Used as scratch variables to communicate multiple values without\n// consing up tons of objects.\nvar type, content;\nfunction ret(tp, style, cont) {\n  type = tp;\n  content = cont;\n  return style;\n}\nfunction haxeTokenBase(stream, state) {\n  var ch = stream.next();\n  if (ch == '\"' || ch == \"'\") {\n    return chain(stream, state, haxeTokenString(ch));\n  } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n    return ret(ch);\n  } else if (ch == \"0\" && stream.eat(/x/i)) {\n    stream.eatWhile(/[\\da-f]/i);\n    return ret(\"number\", \"number\");\n  } else if (/\\d/.test(ch) || ch == \"-\" && stream.eat(/\\d/)) {\n    stream.match(/^\\d*(?:\\.\\d*(?!\\.))?(?:[eE][+\\-]?\\d+)?/);\n    return ret(\"number\", \"number\");\n  } else if (state.reAllowed && ch == \"~\" && stream.eat(/\\//)) {\n    toUnescaped(stream, \"/\");\n    stream.eatWhile(/[gimsu]/);\n    return ret(\"regexp\", \"string.special\");\n  } else if (ch == \"/\") {\n    if (stream.eat(\"*\")) {\n      return chain(stream, state, haxeTokenComment);\n    } else if (stream.eat(\"/\")) {\n      stream.skipToEnd();\n      return ret(\"comment\", \"comment\");\n    } else {\n      stream.eatWhile(isOperatorChar);\n      return ret(\"operator\", null, stream.current());\n    }\n  } else if (ch == \"#\") {\n    stream.skipToEnd();\n    return ret(\"conditional\", \"meta\");\n  } else if (ch == \"@\") {\n    stream.eat(/:/);\n    stream.eatWhile(/[\\w_]/);\n    return ret(\"metadata\", \"meta\");\n  } else if (isOperatorChar.test(ch)) {\n    stream.eatWhile(isOperatorChar);\n    return ret(\"operator\", null, stream.current());\n  } else {\n    var word;\n    if (/[A-Z]/.test(ch)) {\n      stream.eatWhile(/[\\w_<>]/);\n      word = stream.current();\n      return ret(\"type\", \"type\", word);\n    } else {\n      stream.eatWhile(/[\\w_]/);\n      var word = stream.current(),\n        known = keywords.propertyIsEnumerable(word) && keywords[word];\n      return known && state.kwAllowed ? ret(known.type, known.style, word) : ret(\"variable\", \"variable\", word);\n    }\n  }\n}\nfunction haxeTokenString(quote) {\n  return function (stream, state) {\n    if (toUnescaped(stream, quote)) state.tokenize = haxeTokenBase;\n    return ret(\"string\", \"string\");\n  };\n}\nfunction haxeTokenComment(stream, state) {\n  var maybeEnd = false,\n    ch;\n  while (ch = stream.next()) {\n    if (ch == \"/\" && maybeEnd) {\n      state.tokenize = haxeTokenBase;\n      break;\n    }\n    maybeEnd = ch == \"*\";\n  }\n  return ret(\"comment\", \"comment\");\n}\n\n// Parser\n\nvar atomicTypes = {\n  \"atom\": true,\n  \"number\": true,\n  \"variable\": true,\n  \"string\": true,\n  \"regexp\": true\n};\nfunction HaxeLexical(indented, column, type, align, prev, info) {\n  this.indented = indented;\n  this.column = column;\n  this.type = type;\n  this.prev = prev;\n  this.info = info;\n  if (align != null) this.align = align;\n}\nfunction inScope(state, varname) {\n  for (var v = state.localVars; v; v = v.next) if (v.name == varname) return true;\n}\nfunction parseHaxe(state, style, type, content, stream) {\n  var cc = state.cc;\n  // Communicate our context to the combinators.\n  // (Less wasteful than consing up a hundred closures on every call.)\n  cx.state = state;\n  cx.stream = stream;\n  cx.marked = null, cx.cc = cc;\n  if (!state.lexical.hasOwnProperty(\"align\")) state.lexical.align = true;\n  while (true) {\n    var combinator = cc.length ? cc.pop() : statement;\n    if (combinator(type, content)) {\n      while (cc.length && cc[cc.length - 1].lex) cc.pop()();\n      if (cx.marked) return cx.marked;\n      if (type == \"variable\" && inScope(state, content)) return \"variableName.local\";\n      if (type == \"variable\" && imported(state, content)) return \"variableName.special\";\n      return style;\n    }\n  }\n}\nfunction imported(state, typename) {\n  if (/[a-z]/.test(typename.charAt(0))) return false;\n  var len = state.importedtypes.length;\n  for (var i = 0; i < len; i++) if (state.importedtypes[i] == typename) return true;\n}\nfunction registerimport(importname) {\n  var state = cx.state;\n  for (var t = state.importedtypes; t; t = t.next) if (t.name == importname) return;\n  state.importedtypes = {\n    name: importname,\n    next: state.importedtypes\n  };\n}\n// Combinator utils\n\nvar cx = {\n  state: null,\n  column: null,\n  marked: null,\n  cc: null\n};\nfunction pass() {\n  for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n}\nfunction cont() {\n  pass.apply(null, arguments);\n  return true;\n}\nfunction inList(name, list) {\n  for (var v = list; v; v = v.next) if (v.name == name) return true;\n  return false;\n}\nfunction register(varname) {\n  var state = cx.state;\n  if (state.context) {\n    cx.marked = \"def\";\n    if (inList(varname, state.localVars)) return;\n    state.localVars = {\n      name: varname,\n      next: state.localVars\n    };\n  } else if (state.globalVars) {\n    if (inList(varname, state.globalVars)) return;\n    state.globalVars = {\n      name: varname,\n      next: state.globalVars\n    };\n  }\n}\n\n// Combinators\n\nvar defaultVars = {\n  name: \"this\",\n  next: null\n};\nfunction pushcontext() {\n  if (!cx.state.context) cx.state.localVars = defaultVars;\n  cx.state.context = {\n    prev: cx.state.context,\n    vars: cx.state.localVars\n  };\n}\nfunction popcontext() {\n  cx.state.localVars = cx.state.context.vars;\n  cx.state.context = cx.state.context.prev;\n}\npopcontext.lex = true;\nfunction pushlex(type, info) {\n  var result = function () {\n    var state = cx.state;\n    state.lexical = new HaxeLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);\n  };\n  result.lex = true;\n  return result;\n}\nfunction poplex() {\n  var state = cx.state;\n  if (state.lexical.prev) {\n    if (state.lexical.type == \")\") state.indented = state.lexical.indented;\n    state.lexical = state.lexical.prev;\n  }\n}\npoplex.lex = true;\nfunction expect(wanted) {\n  function f(type) {\n    if (type == wanted) return cont();else if (wanted == \";\") return pass();else return cont(f);\n  }\n  return f;\n}\nfunction statement(type) {\n  if (type == \"@\") return cont(metadef);\n  if (type == \"var\") return cont(pushlex(\"vardef\"), vardef1, expect(\";\"), poplex);\n  if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n  if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n  if (type == \"{\") return cont(pushlex(\"}\"), pushcontext, block, poplex, popcontext);\n  if (type == \";\") return cont();\n  if (type == \"attribute\") return cont(maybeattribute);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"for\") return cont(pushlex(\"form\"), expect(\"(\"), pushlex(\")\"), forspec1, expect(\")\"), poplex, statement, poplex);\n  if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n  if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"), block, poplex, poplex);\n  if (type == \"case\") return cont(expression, expect(\":\"));\n  if (type == \"default\") return cont(expect(\":\"));\n  if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"), statement, poplex, popcontext);\n  if (type == \"import\") return cont(importdef, expect(\";\"));\n  if (type == \"typedef\") return cont(typedef);\n  return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n}\nfunction expression(type) {\n  if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);\n  if (type == \"type\") return cont(maybeoperator);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"keyword c\") return cont(maybeexpression);\n  if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeoperator);\n  if (type == \"operator\") return cont(expression);\n  if (type == \"[\") return cont(pushlex(\"]\"), commasep(maybeexpression, \"]\"), poplex, maybeoperator);\n  if (type == \"{\") return cont(pushlex(\"}\"), commasep(objprop, \"}\"), poplex, maybeoperator);\n  return cont();\n}\nfunction maybeexpression(type) {\n  if (type.match(/[;\\}\\)\\],]/)) return pass();\n  return pass(expression);\n}\nfunction maybeoperator(type, value) {\n  if (type == \"operator\" && /\\+\\+|--/.test(value)) return cont(maybeoperator);\n  if (type == \"operator\" || type == \":\") return cont(expression);\n  if (type == \";\") return;\n  if (type == \"(\") return cont(pushlex(\")\"), commasep(expression, \")\"), poplex, maybeoperator);\n  if (type == \".\") return cont(property, maybeoperator);\n  if (type == \"[\") return cont(pushlex(\"]\"), expression, expect(\"]\"), poplex, maybeoperator);\n}\nfunction maybeattribute(type) {\n  if (type == \"attribute\") return cont(maybeattribute);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"var\") return cont(vardef1);\n}\nfunction metadef(type) {\n  if (type == \":\") return cont(metadef);\n  if (type == \"variable\") return cont(metadef);\n  if (type == \"(\") return cont(pushlex(\")\"), commasep(metaargs, \")\"), poplex, statement);\n}\nfunction metaargs(type) {\n  if (type == \"variable\") return cont();\n}\nfunction importdef(type, value) {\n  if (type == \"variable\" && /[A-Z]/.test(value.charAt(0))) {\n    registerimport(value);\n    return cont();\n  } else if (type == \"variable\" || type == \"property\" || type == \".\" || value == \"*\") return cont(importdef);\n}\nfunction typedef(type, value) {\n  if (type == \"variable\" && /[A-Z]/.test(value.charAt(0))) {\n    registerimport(value);\n    return cont();\n  } else if (type == \"type\" && /[A-Z]/.test(value.charAt(0))) {\n    return cont();\n  }\n}\nfunction maybelabel(type) {\n  if (type == \":\") return cont(poplex, statement);\n  return pass(maybeoperator, expect(\";\"), poplex);\n}\nfunction property(type) {\n  if (type == \"variable\") {\n    cx.marked = \"property\";\n    return cont();\n  }\n}\nfunction objprop(type) {\n  if (type == \"variable\") cx.marked = \"property\";\n  if (atomicTypes.hasOwnProperty(type)) return cont(expect(\":\"), expression);\n}\nfunction commasep(what, end) {\n  function proceed(type) {\n    if (type == \",\") return cont(what, proceed);\n    if (type == end) return cont();\n    return cont(expect(end));\n  }\n  return function (type) {\n    if (type == end) return cont();else return pass(what, proceed);\n  };\n}\nfunction block(type) {\n  if (type == \"}\") return cont();\n  return pass(statement, block);\n}\nfunction vardef1(type, value) {\n  if (type == \"variable\") {\n    register(value);\n    return cont(typeuse, vardef2);\n  }\n  return cont();\n}\nfunction vardef2(type, value) {\n  if (value == \"=\") return cont(expression, vardef2);\n  if (type == \",\") return cont(vardef1);\n}\nfunction forspec1(type, value) {\n  if (type == \"variable\") {\n    register(value);\n    return cont(forin, expression);\n  } else {\n    return pass();\n  }\n}\nfunction forin(_type, value) {\n  if (value == \"in\") return cont();\n}\nfunction functiondef(type, value) {\n  //function names starting with upper-case letters are recognised as types, so cludging them together here.\n  if (type == \"variable\" || type == \"type\") {\n    register(value);\n    return cont(functiondef);\n  }\n  if (value == \"new\") return cont(functiondef);\n  if (type == \"(\") return cont(pushlex(\")\"), pushcontext, commasep(funarg, \")\"), poplex, typeuse, statement, popcontext);\n}\nfunction typeuse(type) {\n  if (type == \":\") return cont(typestring);\n}\nfunction typestring(type) {\n  if (type == \"type\") return cont();\n  if (type == \"variable\") return cont();\n  if (type == \"{\") return cont(pushlex(\"}\"), commasep(typeprop, \"}\"), poplex);\n}\nfunction typeprop(type) {\n  if (type == \"variable\") return cont(typeuse);\n}\nfunction funarg(type, value) {\n  if (type == \"variable\") {\n    register(value);\n    return cont(typeuse);\n  }\n}\n\n// Interface\nexport const haxe = {\n  name: \"haxe\",\n  startState: function (indentUnit) {\n    var defaulttypes = [\"Int\", \"Float\", \"String\", \"Void\", \"Std\", \"Bool\", \"Dynamic\", \"Array\"];\n    var state = {\n      tokenize: haxeTokenBase,\n      reAllowed: true,\n      kwAllowed: true,\n      cc: [],\n      lexical: new HaxeLexical(-indentUnit, 0, \"block\", false),\n      importedtypes: defaulttypes,\n      context: null,\n      indented: 0\n    };\n    return state;\n  },\n  token: function (stream, state) {\n    if (stream.sol()) {\n      if (!state.lexical.hasOwnProperty(\"align\")) state.lexical.align = false;\n      state.indented = stream.indentation();\n    }\n    if (stream.eatSpace()) return null;\n    var style = state.tokenize(stream, state);\n    if (type == \"comment\") return style;\n    state.reAllowed = !!(type == \"operator\" || type == \"keyword c\" || type.match(/^[\\[{}\\(,;:]$/));\n    state.kwAllowed = type != '.';\n    return parseHaxe(state, style, type, content, stream);\n  },\n  indent: function (state, textAfter, cx) {\n    if (state.tokenize != haxeTokenBase) return 0;\n    var firstChar = textAfter && textAfter.charAt(0),\n      lexical = state.lexical;\n    if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n    var type = lexical.type,\n      closing = firstChar == type;\n    if (type == \"vardef\") return lexical.indented + 4;else if (type == \"form\" && firstChar == \"{\") return lexical.indented;else if (type == \"stat\" || type == \"form\") return lexical.indented + cx.unit;else if (lexical.info == \"switch\" && !closing) return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? cx.unit : 2 * cx.unit);else if (lexical.align) return lexical.column + (closing ? 0 : 1);else return lexical.indented + (closing ? 0 : cx.unit);\n  },\n  languageData: {\n    indentOnInput: /^\\s*[{}]$/,\n    commentTokens: {\n      line: \"//\",\n      block: {\n        open: \"/*\",\n        close: \"*/\"\n      }\n    }\n  }\n};\nexport const hxml = {\n  name: \"hxml\",\n  startState: function () {\n    return {\n      define: false,\n      inString: false\n    };\n  },\n  token: function (stream, state) {\n    var ch = stream.peek();\n    var sol = stream.sol();\n\n    ///* comments */\n    if (ch == \"#\") {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n    if (sol && ch == \"-\") {\n      var style = \"variable-2\";\n      stream.eat(/-/);\n      if (stream.peek() == \"-\") {\n        stream.eat(/-/);\n        style = \"keyword a\";\n      }\n      if (stream.peek() == \"D\") {\n        stream.eat(/[D]/);\n        style = \"keyword c\";\n        state.define = true;\n      }\n      stream.eatWhile(/[A-Z]/i);\n      return style;\n    }\n    var ch = stream.peek();\n    if (state.inString == false && ch == \"'\") {\n      state.inString = true;\n      stream.next();\n    }\n    if (state.inString == true) {\n      if (stream.skipTo(\"'\")) {} else {\n        stream.skipToEnd();\n      }\n      if (stream.peek() == \"'\") {\n        stream.next();\n        state.inString = false;\n      }\n      return \"string\";\n    }\n    stream.next();\n    return null;\n  },\n  languageData: {\n    commentTokens: {\n      line: \"#\"\n    }\n  }\n};"],
  "mappings": "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",
  "names": ["type", "cont", "content", "cx"]
}
